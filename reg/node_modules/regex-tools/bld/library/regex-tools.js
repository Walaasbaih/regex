"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const FS = tslib_1.__importStar(require("fs"));
const Path = tslib_1.__importStar(require("path"));
const combine_1 = require("./combine");
const REGEX_LITERAL_REGEX = /(\/(?:[^\r\n\u2028\u2029*/\[\\]|\\[^\r\n\u2028\u2029]|\[(?:[^\r\n\u2028\u2029\]\\]|\\[^\r\n\u2028\u2029])*\])(?:[^\r\n\u2028\u2029/\[\\]|\\[^\r\n\u2028\u2029]|\[(?:[^\r\n\u2028\u2029\]\\]|\\[^\r\n\u2028\u2029])*\])*\/[gimy]{0,4})/;
const PARAMS_REGEX = /(\((?:(\s*)([\w$][\w\d$]*)(?:\s*:\s*string)?)?(?:(\s*,\s*)[^)]*\S)?(\s*)\))/;
const GROUPS_REGEX = /(var|let|const)\s+([\w$][\w\d$]*)\s*=\s*($groupName:[\w$][\w\d$]*)\s*\[\s*(\d+)\s*\]\s*;(?:\s*(?:var|let)\s+[\w$][\w\d$]*\s*=\s*($groupName)\s*\[\s*\d+\s*\]\s*;)*/;
const ENUM_REGEX = /(const\s+)?enum\s+([\w$][\w\d$]*)\s*\{[^}]*\}/;
function process(path, skipWrite = false) {
    path = Path.resolve(path);
    let dir = Path.dirname(path);
    let module = require(path);
    let regexToolsOptions = module.default || module.options || module;
    let optionGroups = Array.isArray(regexToolsOptions)
        ? regexToolsOptions
        : [regexToolsOptions];
    let cacheMap = {};
    let targets = [];
    for (let options of optionGroups) {
        let { name, target, operation, flags, regexes } = options;
        target = Path.resolve(dir, target);
        targets.push(target);
        let cache = cacheMap[target];
        let text;
        if (cache) {
            text = cache.text;
        }
        else {
            text = FS.readFileSync(target, 'utf-8');
            cache = cacheMap[target] = {
                original: text,
                text,
            };
        }
        let { newLine, indent } = detectTextStyle(text);
        let result;
        switch (operation) {
            case undefined:
            case 'combine':
                result = combine_1.combine(regexes);
                break;
            default:
                continue;
        }
        let matcherCommentRegex = new RegExp(`([ \\t]*)(/\\*\\s*/\\$${name}/\\s*\\*/\\s*)`);
        let matcherRegex = eval(combine_1.combine([
            matcherCommentRegex,
            {
                regexes: [
                    REGEX_LITERAL_REGEX,
                    PARAMS_REGEX,
                    GROUPS_REGEX,
                    ENUM_REGEX,
                ],
                or: true,
            },
        ]).getRegexLiteral('g'));
        let updatedText = text.replace(matcherRegex, (text, lineIndent, prefix, literal, params, whitespacesBeforeParams, firstParamName, separatorBetweenParams, whitespacesAfterParams, groupDeclarationsKeyword, firstGroupName, groupArrayName, firstGroupIndex, constEnum, enumName) => {
            if (literal) {
                return `${lineIndent}${prefix}${result.getRegexLiteral(flags)}`;
            }
            else if (params) {
                let separator = whitespacesBeforeParams
                    ? `,${whitespacesBeforeParams}`
                    : separatorBetweenParams || ', ';
                return `${lineIndent}${prefix}(${whitespacesBeforeParams}${result.getParametersSnippet({
                    typed: /\.ts$/i.test(target),
                    matchName: firstParamName,
                    separator,
                })}${whitespacesAfterParams})`;
            }
            else if (groupDeclarationsKeyword) {
                return `${lineIndent}${prefix}${result.getGroupAliasDeclarationsSnippet({
                    useLet: groupDeclarationsKeyword === 'let',
                    arrayName: groupArrayName,
                    newLine,
                    lineIndent,
                    matchName: firstGroupIndex === '0' ? firstGroupName : undefined,
                })}`;
            }
            else if (enumName) {
                return `${lineIndent}${prefix}${result.getEnumDeclaration({
                    useConst: !!constEnum,
                    name: enumName,
                    newLine,
                    lineIndent,
                    indent,
                })}`;
            }
            else {
                return text;
            }
        });
        if (updatedText !== text) {
            cache.text = updatedText;
        }
    }
    if (!skipWrite) {
        for (let path of Object.keys(cacheMap)) {
            let cache = cacheMap[path];
            if (cache.text !== cache.original) {
                FS.writeFileSync(path, cache.text);
            }
        }
    }
    let updatedTexts = targets.map(target => cacheMap[target].text);
    return Array.isArray(regexToolsOptions) ? updatedTexts : updatedTexts[0];
}
exports.process = process;
function detectTextStyle(text) {
    let indentSpaces = text.match(/^[ \t]+/gm) || [];
    let tabCount = 0;
    let lastIndentLength;
    let lengthToCount = [];
    for (let indentSpace of indentSpaces) {
        if (/\t/.test(indentSpace)) {
            tabCount++;
        }
        else {
            let length = indentSpace.length;
            if (lastIndentLength !== undefined && length > lastIndentLength) {
                let indentDiff = length - lastIndentLength;
                lengthToCount[indentDiff] = (lengthToCount[indentDiff] || 0) + 1;
            }
            lastIndentLength = length;
        }
    }
    let indent;
    if (tabCount < indentSpaces.length / 2) {
        let indentInfos = lengthToCount
            .map((count, length) => ({
            count,
            length,
        }))
            .sort((a, b) => b.count - a.count);
        if (indentInfos.length) {
            indent = Array(indentInfos[0].length + 1).join(' ');
        }
        else {
            indent = '    ';
        }
    }
    else {
        indent = '\t';
    }
    let newLine = (text.match(/\r/g) || []).length / (text.match(/\n/g) || []).length < 0.5
        ? '\n'
        : '\r\n';
    return {
        indent,
        newLine,
    };
}
//# sourceMappingURL=regex-tools.js.map